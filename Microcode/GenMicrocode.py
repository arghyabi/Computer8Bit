import os
import shutil
import argparse

import CreateAutogenIns
import ParseInstruction

CHIP_AT28C16  = "AT28C16"
CHIP_AT28C256 = "AT28C256"

supportedChip = [CHIP_AT28C16, CHIP_AT28C256]

commentHeader = """\
// This file is generated by GenMicrocode.py
// Do not edit this file directly.
// Edit GenMicrocode.py instead.

// This file contains the microcode for the 8 bit CPU.
// The microcode is used to control the CPU's operations.
// The microcode is a set of instructions that the CPU uses to perform operations.

// The microcode is stored in EEPROM chip number {chipNumber}.
// The Inputs are like  {inputPatterns}
// The outputs are like {outputPatterns}


"""

def genMicrocode(chip, chipNumer, data, inputPatterns, outputPatterns):
    upDatedHeader = commentHeader.format(
        chipNumber     = chipNumer,
        inputPatterns  = inputPatterns,
        outputPatterns = outputPatterns
    )

    with open(os.path.join("out", f"Microcode_{chipNumer}.h"), "w") as f:
        f.write(f"#ifndef _COMPUTER_8_BIT_MICROCODE_CHIP_{chipNumer}_H_\n")
        f.write(f"#define _COMPUTER_8_BIT_MICROCODE_CHIP_{chipNumer}_H_\n\n")
        f.write(upDatedHeader)
        if chip == CHIP_AT28C16:
            f.write("// Microcode ROMs: 11 address lines (2048 addresses), 8 output lines per chip\n")
            f.write("// 3 EEPROMs needed for 19 output lines\n\n")
            f.write(f"// Microcode for EEPROM chip {chipNumer}\n")
            f.write(f"static const unsigned char microcode_chip_{chipNumer}[2048] = {{\n    /* 0x{(chipNumer * len(data)):04X} */")

        if chip == CHIP_AT28C256:
            f.write("// Microcode ROMs: 15 address lines (32768 addresses), 8 output lines per chip\n")
            f.write("// 4 EEPROMs needed for 30 output lines\n\n")
            f.write(f"// Microcode for EEPROM chip {chipNumer}\n")
            f.write(f"static const unsigned char microcode_chip_{chipNumer}[32768] = {{\n    /* 0x{(chipNumer * len(data)):04X} */")

        for addr, dataByte in enumerate(data):
            f.write(f" 0x{dataByte:02X},")
            if (addr + 1) % 8 == 0 and (addr + 1) % 16 != 0:
                f.write(f"  ")
            if (addr + 1) % 16 == 0:
                f.write(f"\n    /* 0x{(addr + (chipNumer * len(data)) + 1):04X} */")
        f.write(" };\n\n")
        f.write(f"#endif // _COMPUTER_8_BIT_MICROCODE_CHIP_{chipNumer}_H_\n")

    with open(os.path.join("out", f"Microcode_{chipNumer}.bin"), "wb") as f:
        # write the binary data to a file
        f.write(bytes(data))


def main():
    parser = argparse.ArgumentParser(prog = 'GenMicrocode')
    parser.add_argument(
        '-c',
        '--chip',
        choices = supportedChip,
        default = CHIP_AT28C256,
        help    = 'select chip from AT28C16 or AT28C256'
    )

    args = parser.parse_args()
    chipName = args.chip

    if os.path.exists("out"):
        shutil.rmtree("out")

    parser = CreateAutogenIns.GenAutoInstructions()
    parser.parseEachInstruction()

    insParser = ParseInstruction.ParseInstructions(chipName)
    insParser.parseEachInstruction()
    microcodeBank, microInsMatrix = insParser.generateAddressDataMap()
    for chipNumber in microcodeBank:
        print(f"Creating Microcode for Chip: {chipNumber}")
        eachChipMicrocode = microcodeBank[chipNumber]
        if microInsMatrix:
            genMicrocode(chipName, int(chipNumber), eachChipMicrocode, microInsMatrix["in"], microInsMatrix["out"][chipNumber])
        else:
            print("Microcode index is null!!")
    print("Done!")


if __name__ == "__main__":
    main()
