import os
import shutil

import ParseInstruction

INPUT_SIZE = 15

commentHeader = """\
// This file is generated by GenMicrocode.py
// Do not edit this file directly.
// Edit GenMicrocode.py instead.

// This file contains the microcode for the CPU.
// The microcode is used to control the CPU's operations.
// The microcode is a set of instructions that the CPU uses to perform operations.

// The microcode is stored in EEPROM chip number {chipNumber}.
// The Inputs are like  {inputPatterns}
// The outputs are like {outputPatterns}


"""
if INPUT_SIZE == 11:
    dataBlock = [0]*2048

if INPUT_SIZE == 15:
    dataBlock = [0]*32768

def genMicrocode(chipNumer, data, inputPatterns, outputPatterns):
    upDatedHeader = commentHeader.format(chipNumber = chipNumer, inputPatterns = inputPatterns, outputPatterns = outputPatterns)

    with open(os.path.join("out", f"Microcode_{chipNumer}.h"), "w") as f:
        f.write(f"#ifndef _COMPUTER_8_BIT_MICROCODE_CHIP_{chipNumer}_H_\n")
        f.write(f"#define _COMPUTER_8_BIT_MICROCODE_CHIP_{chipNumer}_H_\n\n")
        f.write(upDatedHeader)
        if INPUT_SIZE == 11:
            f.write("// Microcode ROMs: 11 address lines (2048 addresses), 8 output lines per chip\n")
            f.write("// 3 EEPROMs needed for 19 output lines\n\n")
            f.write(f"// Microcode for EEPROM chip {chipNumer}\n")
            f.write(f"static const unsigned char microcode_chip_{chipNumer}[2048] = {{\n    /* 0x{(chipNumer * len(data)):04X} */")

        if INPUT_SIZE == 15:
            f.write("// Microcode ROMs: 15 address lines (32768 addresses), 8 output lines per chip\n")
            f.write("// 4 EEPROMs needed for 30 output lines\n\n")
            f.write(f"// Microcode for EEPROM chip {chipNumer}\n")
            f.write(f"static const unsigned char microcode_chip_{chipNumer}[32768] = {{\n    /* 0x{(chipNumer * len(data)):04X} */")

        for addr, dataByte in enumerate(data):
            f.write(f" 0x{dataByte:02X},")
            if (addr + 1) % 8 == 0 and (addr + 1) % 16 != 0:
                f.write(f"  ")
            if (addr + 1) % 16 == 0:
                f.write(f"\n    /* 0x{(addr + (chipNumer * len(data)) + 1):04X} */")
        f.write(" };\n\n")
        f.write(f"#endif // _COMPUTER_8_BIT_MICROCODE_CHIP_{chipNumer}_H_\n")

    with open(os.path.join("out", f"Microcode_{chipNumer}.bin"), "wb") as f:
        # write the binary data to a file
        f.write(bytes(data))


def updateMicrocode(chipNumber, address, data):
    if 0 <= address < len(dataBlock):
        dataBlock[address] = data
    else:
        print(f"Error: Address {address} out of range for chip {chipNumber}.")


def randomizeMicrocode(chipNumber):
    import random
    for i in range(len(dataBlock)):
        dataBlock[i] = random.randint(0, 255)
    genMicrocode(chipNumber, dataBlock, None, None)


def main():
    insParser = ParseInstruction.ParseInstructions(INPUT_SIZE)
    insParser.parseEachInstruction()
    if os.path.exists("out"):
        shutil.rmtree("out")
    # print("=====================================")
    microcodeBank, microInsMatrix = insParser.generateAddressDataMap()
    for chip in microcodeBank:
        print(f"Creating Microcode for Chip: {chip}")
        eachChipMicrocode = microcodeBank[chip]
        # print(f"{eachChipMicrocode}")
        genMicrocode(int(chip), eachChipMicrocode, microInsMatrix["in"], microInsMatrix["out"][chip])
    print("Done!")

if __name__ == "__main__":
    # randomizeMicrocode(1)
    # print("Microcode files generated successfully.")
    main()
